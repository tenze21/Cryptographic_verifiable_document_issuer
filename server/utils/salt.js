import pkg from "lodash";
const { includes, mapValues, map, identity } = pkg;
import { v4 as uuid } from "uuid";
import { version as uuidVersion } from "uuid";
import { validate as uuidValidate } from "uuid";

// UUID v4 length including the colon
const UUID_LENGTH = 37;
const PRIMITIVE_TYPES = ["string", "number", "boolean", "undefined"];


/**
 If the value is a primitive type the @iteratee function which is the @uuidSalt function is called on the value,
 and if the value is not of primitive type then @deepMap is called to map through the array or object and pass the values to the @recursivelyApply function.
**/
const recursivelyApply = (iteratee) => (value) => {
  if (includes(PRIMITIVE_TYPES, typeof value) || value === null) {
    return iteratee(value);
  }
  return deepMap(value, iteratee);
};

export const deepMap = (collection, iteratee = identity) => {
/**
 The lodash @map Creates an array of values by running each element
 in collection thru iteratee.
**/
  if (Array.isArray(collection)) {
    return map(collection, recursivelyApply(iteratee));
  }

  /**
   The lodash @mapValues function creates an object with the same keys as object and values 
   generated by running each own enumerable string keyed property of object thru iteratee.
  **/
  if (typeof collection === "object" && collection !== null) {
    return mapValues(collection, recursivelyApply(iteratee));
  }
  return collection;
};

/** 
 This function converts a primitive value to a string with a type annotation
 if @param value=="tenzin":
    @returns "string:tenzin"
 **/
const primitiveToTypedString = (value) => {
  switch (typeof value) {
    case "string":
    case "number":
    case "boolean":
    case "undefined":
      return `${typeof value}: ${String(value)}`;
    default:
      if (value === null) {
        // typeof null is 'object' so we have to check for it
        return "null:null";
      }
      throw new Error(
        `Parsing error, value is not of primitive type: ${value}`
      );
  }
};

/**
 This is the iteratee function that is applied to each value of the collection
 if @param value=="tenzin":
    @returns "salt:string:tenzin"
 salt is a random string of characters generated by the @uuid function.
**/
const uuidSalt = (value) => {
  // generate a random UUID v4
  const salt = uuid();
  return `${salt}:${primitiveToTypedString(value)}`;
};

/**
  Restores the value to it's initial primitive type after removing the salt.

  if @param input === "string:ten:zin":
    @line84 ["string", "ten", "zin"]
    @line87 ["string", "ten:zin"]
**/
const typedStringToPrimitive=(input)=>{
    const [type, ...valueArray]= input.split(':');
    const value= valueArray.join(':');
    switch(type){
        case "number":
            return Number(value);
        case "string":
            return String(value);
        case "boolean":
            return value==="true";
        case "null":
            return null;
        case "undefined":
            return undefined;
        default:
            throw new Error(`Parsing error, type annotation not found in string: ${input}`)
    }
}

// This function checks if a string starts with a valid UUID v4(version 4) string.
const startsWithUuidv4=(value)=>{
    if(value && typeof value==='string'){
        const elements=value.split(':');
        return uuidValidate(elements[0]) && uuidVersion(elements[0])===4;
    }
    return false;
}

/**
  Remove the salt from the value and convert the value back to it's primitive type
  if @param value === "salt:string:tenzin":
    @call typedStringToPrimitive("string:tenzin")
**/
export const unSalt=(value)=>{
    if(startsWithUuidv4(value)){
        const untypedValue= value.substring(UUID_LENGTH).trim();
        return typedStringToPrimitive(untypedValue);
    }
    return value;
}

export const saltData = (data) => deepMap(data, uuidSalt);
export const unSaltData = (data) => deepMap(data, unSalt);
